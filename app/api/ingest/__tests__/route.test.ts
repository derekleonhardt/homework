import { beforeEach, describe, expect, it, vi } from 'vitest'

const { enrichItemMock, runAiTaggingMock, searchBookMock, withTxMock } = vi.hoisted(() => ({
  withTxMock: vi.fn(),
  enrichItemMock: vi.fn(),
  runAiTaggingMock: vi.fn(),
  searchBookMock: vi.fn(),
}))

vi.mock('@/lib/db', () => ({
  withTx: withTxMock,
}))

vi.mock('@/lib/metadata/enrich', () => ({
  enrichItem: enrichItemMock,
}))

vi.mock('@/lib/metadata/ai-tagger', () => ({
  runAiTagging: runAiTaggingMock,
}))

vi.mock('@/lib/metadata/extractors/google-books', () => ({
  searchBook: searchBookMock,
}))

vi.mock('@/lib/logger', () => ({
  logger: { debug: vi.fn(), info: vi.fn(), warn: vi.fn(), error: vi.fn() },
}))

import { POST } from '../route'

interface StoredItem {
  id: string
  url: string | null
  title: string
  type: string
  createdAt: Date
  updatedAt: Date
  description: string | null
  imageUrl: string | null
  imageWidth: number | null
  imageHeight: number | null
  faviconUrl: string | null
  siteName: string | null
  author: string | null
  publishedAt: Date | null
  wordCount: number | null
  readingTime: number | null
  status: string
  metadataStatus: string
  enrichmentSource: string | null
  rawInput: string
  pageCount: number | null
}

interface StoredTag {
  id: string
  name: string
  slug: string
  color: string
  isAutoGenerated: boolean
}

interface StoredItemTag {
  itemId: string
  tagId: string
  isAutoGenerated: boolean
}

let items: StoredItem[] = []
let tags: StoredTag[] = []
let itemTags: StoredItemTag[] = []
let nextId = 2

function withTags(item: StoredItem) {
  return {
    ...item,
    tags: itemTags
      .filter((it) => it.itemId === item.id)
      .map((it) => ({ tag: tags.find((tag) => tag.id === it.tagId) })),
  }
}

function setupInMemoryTx() {
  withTxMock.mockImplementation(async (fn: (tx: unknown) => Promise<unknown>) => {
    const tx = {
      item: {
        findFirst: vi.fn(async ({ where }: { where: Record<string, unknown> }) => {
          if (where.url !== undefined) {
            const matches = items.filter((item) => item.url === where.url)
            return matches.length > 0 ? matches[matches.length - 1] : null
          }
          if (where.rawInput !== undefined) {
            const matches = items.filter(
              (item) =>
                item.rawInput === where.rawInput &&
                (where.type === undefined || item.type === where.type),
            )
            return matches.length > 0 ? matches[matches.length - 1] : null
          }
          return null
        }),
        create: vi.fn(
          async ({
            data,
            select,
          }: { data: Record<string, unknown>; select?: { id?: boolean } }) => {
            const now = new Date()
            const created: StoredItem = {
              id: `item-${nextId++}`,
              url: (data.url as string | null | undefined) ?? null,
              title: (data.title as string) ?? '',
              type: (data.type as string | undefined) ?? 'article',
              createdAt: now,
              updatedAt: now,
              description: (data.description as string | null | undefined) ?? '',
              imageUrl: (data.imageUrl as string | null | undefined) ?? null,
              imageWidth: (data.imageWidth as number | null | undefined) ?? null,
              imageHeight: (data.imageHeight as number | null | undefined) ?? null,
              faviconUrl: (data.faviconUrl as string | null | undefined) ?? null,
              siteName: (data.siteName as string | null | undefined) ?? null,
              author: (data.author as string | null | undefined) ?? null,
              publishedAt: (data.publishedAt as Date | null | undefined) ?? null,
              wordCount: (data.wordCount as number | null | undefined) ?? null,
              readingTime: (data.readingTime as number | null | undefined) ?? null,
              status: (data.status as string | undefined) ?? 'inbox',
              metadataStatus: (data.metadataStatus as string | undefined) ?? 'pending',
              enrichmentSource: (data.enrichmentSource as string | null | undefined) ?? null,
              rawInput: (data.rawInput as string) ?? '',
              pageCount: (data.pageCount as number | null | undefined) ?? null,
            }
            items.push(created)

            if (select?.id) {
              return { id: created.id }
            }
            return created
          },
        ),
        findUnique: vi.fn(async ({ where }: { where: { id: string } }) => {
          const found = items.find((item) => item.id === where.id)
          return found ? withTags(found) : null
        }),
      },
      itemTag: {
        findMany: vi.fn(async ({ where }: { where: { itemId: string } }) =>
          itemTags
            .filter((it) => it.itemId === where.itemId)
            .map((it) => ({ tagId: it.tagId, isAutoGenerated: it.isAutoGenerated })),
        ),
        createMany: vi.fn(async ({ data }: { data: StoredItemTag[] }) => {
          itemTags.push(...data)
          return { count: data.length }
        }),
      },
    }

    return fn(tx)
  })
}

function makeRequest(input: string): Request {
  return new Request('http://localhost/api/ingest', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ input }),
  })
}

describe('POST /api/ingest duplicate URL behavior', () => {
  beforeEach(() => {
    vi.clearAllMocks()

    items = [
      {
        id: 'item-1',
        url: 'https://example.com',
        title: 'Existing title',
        type: 'article',
        createdAt: new Date('2026-01-01T00:00:00.000Z'),
        updatedAt: new Date('2026-01-01T00:00:00.000Z'),
        description: 'Existing description',
        imageUrl: 'https://example.com/image.jpg',
        imageWidth: 1200,
        imageHeight: 630,
        faviconUrl: 'https://example.com/favicon.ico',
        siteName: 'Example',
        author: 'Author',
        publishedAt: new Date('2025-12-31T00:00:00.000Z'),
        wordCount: 600,
        readingTime: 3,
        status: 'inbox',
        metadataStatus: 'completed',
        enrichmentSource: 'metascraper',
        rawInput: 'https://example.com',
        pageCount: null,
      },
    ]
    tags = [
      {
        id: 'tag-1',
        name: 'engineering',
        slug: 'engineering',
        color: '#6b7280',
        isAutoGenerated: true,
      },
    ]
    itemTags = [{ itemId: 'item-1', tagId: 'tag-1', isAutoGenerated: true }]
    nextId = 2

    setupInMemoryTx()

    enrichItemMock.mockResolvedValue(undefined)
    runAiTaggingMock.mockResolvedValue(undefined)
    searchBookMock.mockResolvedValue(null)
  })

  it('creates a new item ID for duplicate URL ingest', async () => {
    const response = await POST(makeRequest('https://example.com') as never)
    const data = (await response.json()) as {
      item: { id: string; tags: Array<{ tag: { slug: string } }> }
    }

    expect(response.status).toBe(201)
    expect(data.item.id).not.toBe('item-1')
    expect(data.item.tags).toHaveLength(1)
    expect(data.item.tags[0].tag.slug).toBe('engineering')
    expect(items).toHaveLength(2)
  })

  it('skips metadata enrichment for duplicate URL ingest', async () => {
    const response = await POST(makeRequest('https://example.com') as never)

    expect(response.status).toBe(201)
    expect(enrichItemMock).not.toHaveBeenCalled()
    expect(runAiTaggingMock).not.toHaveBeenCalled()
  })
})
