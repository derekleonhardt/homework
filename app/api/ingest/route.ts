import { type TransactionClient, withTx } from '@/lib/db'
import { parseInput } from '@/lib/input-parser'
import { logger } from '@/lib/logger'
import { runAiTagging } from '@/lib/metadata/ai-tagger'
import { enrichItem } from '@/lib/metadata/enrich'
import { searchBook } from '@/lib/metadata/extractors/google-books'
import { ingestSchema, parseJsonBody } from '@/lib/validation'
import type { Prisma } from '@prisma/client'
import type { NextRequest } from 'next/server'
import { NextResponse, after } from 'next/server'

const itemWithTagsInclude = {
  tags: { include: { tag: true } },
} as const

type ItemWithTags = Prisma.ItemGetPayload<{ include: typeof itemWithTagsInclude }>

async function copyItemTags(
  tx: TransactionClient,
  sourceItemId: string,
  targetItemId: string,
): Promise<void> {
  const sourceTags = await tx.itemTag.findMany({
    where: { itemId: sourceItemId },
    select: { tagId: true, isAutoGenerated: true },
  })

  if (sourceTags.length === 0) return

  await tx.itemTag.createMany({
    data: sourceTags.map((tag) => ({
      itemId: targetItemId,
      tagId: tag.tagId,
      isAutoGenerated: tag.isAutoGenerated,
    })),
  })
}

async function createItemWithCopiedTags(
  sourceItemId: string,
  data: Prisma.ItemCreateInput,
): Promise<ItemWithTags | null> {
  return withTx(async (tx) => {
    const createdItem = await tx.item.create({
      data,
      select: { id: true },
    })

    await copyItemTags(tx, sourceItemId, createdItem.id)

    return tx.item.findUnique({
      where: { id: createdItem.id },
      include: itemWithTagsInclude,
    })
  })
}

function isAllowedExtensionOrigin(origin: string | null): boolean {
  if (!origin) return false

  return origin.startsWith('chrome-extension://') || origin.startsWith('moz-extension://')
}

function getCorsHeaders(origin: string): Record<string, string> {
  return {
    'Access-Control-Allow-Origin': origin,
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Cookie',
    'Access-Control-Allow-Credentials': 'true',
  }
}

export async function OPTIONS(request: Request) {
  const origin = request.headers.get('origin')

  if (!origin || !isAllowedExtensionOrigin(origin)) {
    return new NextResponse(null, { status: 403 })
  }

  return NextResponse.json({}, { headers: getCorsHeaders(origin) })
}

function normalizeUrl(url: string): string {
  try {
    const parsed = new URL(url)
    parsed.hostname = parsed.hostname.toLowerCase()
    let normalized = parsed.href
    if (normalized.endsWith('/') && parsed.pathname === '/') {
      normalized = normalized.slice(0, -1)
    }
    return normalized
  } catch {
    return url.trim()
  }
}

export async function POST(request: NextRequest) {
  const origin = request.headers.get('origin')
  const corsHeaders =
    origin && isAllowedExtensionOrigin(origin) ? getCorsHeaders(origin) : undefined

  const bodyResult = await parseJsonBody(request, ingestSchema)
  if (!bodyResult.success) {
    return NextResponse.json({ error: bodyResult.error }, { status: 400, headers: corsHeaders })
  }
  const rawInput = bodyResult.data.input

  try {
    const parsed = parseInput(rawInput)

    if (parsed.contentType === 'book') {
      return handleBookInput(parsed.title, parsed.author, rawInput, corsHeaders)
    }

    if (parsed.contentType === 'note') {
      return handleTextInput(parsed.text, corsHeaders)
    }

    return handleUrlInput(parsed.url, parsed.contentType, corsHeaders)
  } catch (error) {
    // Input validation errors (e.g., empty/whitespace input) → 400
    if (error instanceof Error && error.message === 'Input cannot be empty') {
      return NextResponse.json(
        { error: 'Input cannot be empty' },
        { status: 400, headers: corsHeaders },
      )
    }
    logger.error('Failed to ingest item', error)
    return NextResponse.json(
      { error: 'Failed to save item' },
      { status: 500, headers: corsHeaders },
    )
  }
}

/**
 * Handle URL input - existing behavior with metadata enrichment
 */
async function handleUrlInput(
  url: string,
  contentType: 'article' | 'video' | 'post' | 'podcast',
  corsHeaders?: Record<string, string>,
) {
  const normalizedUrl = normalizeUrl(url)

  const existingItem = await withTx((tx) =>
    tx.item.findFirst({
      where: { url: normalizedUrl },
      orderBy: { createdAt: 'desc' },
    }),
  )
  if (existingItem) {
    const duplicatedItem = await createItemWithCopiedTags(existingItem.id, {
      url: normalizedUrl,
      title: existingItem.title,
      type: existingItem.type,
      status: 'inbox',
      metadataStatus: existingItem.metadataStatus,
      description: existingItem.description,
      imageUrl: existingItem.imageUrl,
      imageWidth: existingItem.imageWidth,
      imageHeight: existingItem.imageHeight,
      faviconUrl: existingItem.faviconUrl,
      siteName: existingItem.siteName,
      author: existingItem.author,
      publishedAt: existingItem.publishedAt,
      wordCount: existingItem.wordCount,
      readingTime: existingItem.readingTime,
      enrichmentSource: existingItem.enrichmentSource,
      rawInput: url,
      pageCount: existingItem.pageCount,
    })
    if (!duplicatedItem) {
      return NextResponse.json({ error: 'Item not found' }, { status: 404, headers: corsHeaders })
    }

    return NextResponse.json({ item: duplicatedItem }, { status: 201, headers: corsHeaders })
  }

  const item = await withTx((tx) =>
    tx.item.create({
      data: {
        url: normalizedUrl,
        title: normalizedUrl,
        type: contentType,
        status: 'inbox',
        metadataStatus: 'pending',
        rawInput: url,
      },
      select: { id: true },
    }),
  )

  // Wait for metadata enrichment.
  const enrichResult = await enrichItem(item.id, normalizedUrl)

  if (enrichResult) {
    after(runAiTagging(item.id, enrichResult.aiTagInput))
  }

  const enrichedItem = await withTx((tx) =>
    tx.item.findUnique({
      where: { id: item.id },
      include: itemWithTagsInclude,
    }),
  )
  if (!enrichedItem) {
    return NextResponse.json({ error: 'Item not found' }, { status: 404, headers: corsHeaders })
  }

  return NextResponse.json({ item: enrichedItem }, { status: 201, headers: corsHeaders })
}

/**
 * Handle book input - enrich via Google Books API.
 */
async function handleBookInput(
  title: string,
  author: string | null,
  rawInput: string,
  corsHeaders?: Record<string, string>,
) {
  const existingItem = await withTx((tx) =>
    tx.item.findFirst({
      where: { rawInput, type: 'book' },
      orderBy: { createdAt: 'desc' },
    }),
  )
  if (existingItem) {
    const duplicatedItem = await createItemWithCopiedTags(existingItem.id, {
      url: null,
      title: existingItem.title,
      type: 'book',
      status: 'inbox',
      metadataStatus: existingItem.metadataStatus,
      enrichmentSource: existingItem.enrichmentSource,
      rawInput,
      author: existingItem.author,
      description: existingItem.description,
      imageUrl: existingItem.imageUrl,
      pageCount: existingItem.pageCount,
    })
    if (!duplicatedItem) {
      return NextResponse.json({ error: 'Item not found' }, { status: 404, headers: corsHeaders })
    }

    return NextResponse.json({ item: duplicatedItem }, { status: 201, headers: corsHeaders })
  }

  // Try to enrich via Google Books.
  const bookData = await searchBook(title, author)

  const item = await withTx((tx) =>
    tx.item.create({
      data: {
        url: null,
        title: bookData?.title || title,
        type: 'book',
        status: 'inbox',
        metadataStatus: bookData ? 'completed' : 'pending',
        enrichmentSource: bookData ? 'google_books' : null,
        rawInput,
        author: bookData?.author || author,
        description: bookData?.description,
        imageUrl: bookData?.imageUrl,
        pageCount: bookData?.pageCount,
      },
      include: itemWithTagsInclude,
    }),
  )

  after(
    runAiTagging(item.id, {
      title: bookData?.title || title,
      author: bookData?.author || author || undefined,
      description: bookData?.description || undefined,
      type: 'book',
    }),
  )

  return NextResponse.json({ item }, { status: 201, headers: corsHeaders })
}

const MAX_TITLE_LENGTH = 500

/**
 * Handle plain text input - save as-is.
 */
async function handleTextInput(text: string, corsHeaders?: Record<string, string>) {
  const existingItem = await withTx((tx) =>
    tx.item.findFirst({
      where: { rawInput: text, type: 'note' },
      orderBy: { createdAt: 'desc' },
    }),
  )
  if (existingItem) {
    const duplicatedItem = await createItemWithCopiedTags(existingItem.id, {
      url: null,
      title: existingItem.title,
      type: 'note',
      status: 'inbox',
      metadataStatus: existingItem.metadataStatus,
      rawInput: text,
      description: existingItem.description,
      imageUrl: existingItem.imageUrl,
      imageWidth: existingItem.imageWidth,
      imageHeight: existingItem.imageHeight,
      faviconUrl: existingItem.faviconUrl,
      siteName: existingItem.siteName,
      author: existingItem.author,
      publishedAt: existingItem.publishedAt,
      wordCount: existingItem.wordCount,
      readingTime: existingItem.readingTime,
      enrichmentSource: existingItem.enrichmentSource,
      pageCount: existingItem.pageCount,
    })
    if (!duplicatedItem) {
      return NextResponse.json({ error: 'Item not found' }, { status: 404, headers: corsHeaders })
    }

    return NextResponse.json({ item: duplicatedItem }, { status: 201, headers: corsHeaders })
  }

  // Truncate title for display, keep full text in rawInput.
  const title = text.length > MAX_TITLE_LENGTH ? `${text.slice(0, MAX_TITLE_LENGTH - 1)}…` : text

  const item = await withTx((tx) =>
    tx.item.create({
      data: {
        url: null,
        title,
        type: 'note',
        status: 'inbox',
        metadataStatus: 'completed',
        rawInput: text,
      },
      include: itemWithTagsInclude,
    }),
  )

  after(
    runAiTagging(item.id, {
      rawInput: text.slice(0, 1000),
      type: 'note',
    }),
  )

  return NextResponse.json({ item }, { status: 201, headers: corsHeaders })
}
